# -*- coding: utf-8 -*-
"""Class 6: Clustering - master.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iJ3SANwNAV2LezSiNpRQ7oCijwuJouu3

# Import packages
"""

!pip install sklearn

import pandas as pd
import numpy as np
from sklearn.cluster import KMeans
from sklearn.datasets import load_breast_cancer
import seaborn as sns
from sklearn.cluster import MeanShift, estimate_bandwidth
from sklearn.mixture import GaussianMixture
import matplotlib.pyplot as plt
from matplotlib.patches import Ellipse
import scipy
from scipy.cluster.hierarchy import dendrogram, linkage

"""# Import code"""

# Load dataset module and look at what's contained inside.
cancer = load_breast_cancer()
cancer

# Grab just the data and columns
# Stack overflow source: https://stackoverflow.com/questions/44340445/loading-sklearn-cancer-dataset-into-pandas-dataframe
cancer_df = pd.DataFrame(np.c_[cancer['target'], cancer['data']],
                  columns= np.append(['target'], cancer['feature_names']))

cancer_df.head()

"""# Exploratory visualizations"""

# Visualize dataset in two dimensions using a scatter plot
sns.scatterplot(x='mean radius', y='target', data=cancer_df)

# Visualize dataset in two dimensions using a scatter plot
# More advanced, for many categories
cancerous = cancer_df['mean radius'].loc[cancer_df['target'] == 1]
noncancerous = cancer_df['mean radius'].loc[cancer_df['target'] == 0]
sns.distplot(cancerous, hist = False, kde = True)
sns.distplot(noncancerous, hist = False, kde = True)

"""# K-means clustering"""

# Break the dataset out into the features and labels
cancer_features = cancer_df.loc[:, 'mean radius':]
cancer_labels = cancer_df[['target']]

# Define k-means parameters and cluster
clusters = KMeans(n_clusters=2).fit_predict(cancer_features)

# Plot the results as a two-dimensional scatter plot
sns.scatterplot(cancer_features['mean radius'], cancer_features['mean smoothness'], hue=clusters)

"""# Expectation-maximization clustering"""

def draw_ellipse(position, covariance, ax=None, **kwargs):
    """Draw an ellipse with a given position and covariance"""
    ax = ax or plt.gca()
    
    # Convert covariance to principal axes
    if covariance.shape == (2, 2):
        U, s, Vt = np.linalg.svd(covariance)
        angle = np.degrees(np.arctan2(U[1, 0], U[0, 0]))
        width, height = 2 * np.sqrt(s)
    else:
        angle = 0
        width, height = 2 * np.sqrt(covariance)
    
    # Draw the Ellipse
    for nsig in range(1, 4):
        ax.add_patch(Ellipse(position, nsig * width, nsig * height,
                             angle, **kwargs), )

def plot_gmm(gmm, X, label=True, ax=None):
    ax = ax or plt.gca()
    labels = gmm.fit(X).predict(X)
    if label:
        ax.scatter(X[:, 0], X[:, 1], c=labels, s=40, cmap='viridis', zorder=2, vmin=0, vmax=.2)
    else:
        ax.scatter(X[:, 0], X[:, 1], s=40, zorder=2).set_ylim(top=.2, bottom = 0, vmin=0, vmax=.2)
        
    w_factor = 0.2 / gmm.weights_.max()
    for pos, covar, w in zip(gmm.means_, gmm.covariances_, gmm.weights_):
        draw_ellipse(pos, covar, alpha=w * w_factor)

# EM clustering
gmm = GaussianMixture(n_components=2, covariance_type='full')
gmm.fit(cancer_features[['mean radius', 'mean smoothness']])

plot_gmm(gmm, np.array(cancer_features[['mean radius', 'mean smoothness']]))

"""# Mean-shift clustering"""

# Compute clustering with MeanShift
# The following bandwidth can be automatically detected using
bandwidth = estimate_bandwidth(cancer_features, quantile=0.8)

ms = MeanShift(bandwidth=bandwidth, bin_seeding=True)
#ms.fit(cancer_features[['mean radius', 'mean smoothness']])
ms.fit(cancer_features)
labels = ms.labels_
cluster_centers = ms.cluster_centers_

labels_unique = np.unique(labels)
n_clusters_ = len(labels_unique)

print("number of estimated clusters : %d" % n_clusters_)

# Add the centers to a dataframe
centers_df = pd.DataFrame(cluster_centers).head()
# centers_df.columns = ['x', 'y']
centers_df['x'] = centers_df[0]
centers_df['y'] = centers_df[2]
centers_df.head()

# Plot clusters in two dimensions and overlay the centers
sns.scatterplot(x='mean radius', y='mean perimeter', data=cancer_features, hue=labels)
sns.scatterplot(x='x', y='y', data=centers_df, color='green', s=100)

"""# Hierarchical clustering"""

# https://scikit-learn.org/stable/modules/generated/sklearn.cluster.AgglomerativeClustering.html#sklearn.cluster.AgglomerativeClustering
from sklearn.cluster import AgglomerativeClustering

for linkage in ('ward', 'average', 'complete', 'single'):
    clustering = AgglomerativeClustering(linkage=linkage, n_clusters=3)
    #t0 = time()
    clustering.fit(cancer_features[['mean radius', 'mean smoothness']])
    #print("%s :\t%.2fs" % (linkage, time() - t0))

    sns.scatterplot(x='mean radius', y='mean smoothness', data=cancer_features, hue=clustering.labels_)
    plt.figure()

"""# Dendrogram plot"""

# Take top 30 observations and plot dendrogram
linkage_data = linkage(cancer_features[['mean radius', 'mean smoothness']].tail(30), method='centroid')
scipy.cluster.hierarchy.dendrogram(linkage_data)
plt.show()

# Show full dataset dendrogram
linkage_data = linkage(cancer_features[['mean radius', 'mean smoothness']], method='centroid')
scipy.cluster.hierarchy.dendrogram(linkage_data)
plt.show()

# Now limit the number of trees allowed and re-plot
# Truncate mode = 'lastp': The last p non-singleton clusters formed in the linkage are the only non-leaf nodes in the 
#  linkage; they correspond to rows Z[n-p-2:end] in Z. All other non-singleton clusters are contracted into leaf nodes.
linkage_data = linkage(cancer_features[['mean radius', 'mean smoothness']], method='centroid')
scipy.cluster.hierarchy.dendrogram(linkage_data, truncate_mode='lastp', p=30)
plt.show()

# Now limit the number levels in the tree and re-plot
# Truncate mode = 'level': No more than p levels of the dendrogram tree are displayed. A “level” includes all nodes with p
#  merges from the last merge.
linkage_data = linkage(cancer_features[['mean radius', 'mean smoothness']], method='centroid')
scipy.cluster.hierarchy.dendrogram(linkage_data, truncate_mode='level', p=2)
plt.show()